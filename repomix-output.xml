This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: lib/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
lib/
  auth.ts
  authOptions.ts
  authServer.ts
  cloudinary.ts
  db.ts
  menu.ts
  settings.ts
  utils.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="lib/auth.ts">
// lib/auth.ts
import { getServerSession } from "next-auth/next";
import { authOptions } from "./authOptions";
import { prisma } from "./db";
import { notFound } from "next/navigation";
import { hash, compare } from "bcrypt";

export async function getCurrentUser() {
	const session = await getServerSession(authOptions);
	if (!session?.user?.id) return null;
	return prisma.user.findUnique({ where: { id: session.user.id } });
}

/** 「STAFF か ADMIN」なら通す */
export async function requireStaff() {
	const user = await getCurrentUser();
	if (!user || (user.role !== "STAFF" && user.role !== "ADMIN")) {
		// 権限無し → 404 と同じ挙動
		notFound();
	}
	return user;
}

/** もし本当に ADMIN 専用が欲しい時だけ使う */
export async function requireAdmin() {
	const user = await getCurrentUser();
	if (!user || user.role !== "ADMIN") {
		notFound();
	}
	return user;
}

/**
 * 平文パスワードをハッシュ化
 */
export async function hashPassword(password: string): Promise<string> {
	const SALT_ROUNDS = 12;
	return await hash(password, SALT_ROUNDS);
}

/**
 * 平文パスワードとハッシュを比較
 */
export async function verifyPassword(
	password: string,
	hashedPassword: string,
): Promise<boolean> {
	return await compare(password, hashedPassword);
}
</file>

<file path="lib/authServer.ts">
// lib/auth-server.ts

import { cookies } from "next/headers";
import { redirect } from "next/navigation";
import { prisma } from "./db";
import { hashPassword, verifyPassword } from "./auth";
import type { User } from "@prisma/client";

/**
 * 新規ユーザー登録を行い、
 * セッション用の cookie (userId) をセットします。
 */
export async function signUp(email: string, password: string, name: string) {
	// 既に同一メールアドレスのユーザーがいないかチェック
	const existing = await prisma.user.findUnique({ where: { email } });
	if (existing) {
		throw new Error("User already exists");
	}

	// パスワードをハッシュ化
	const hashed = await hashPassword(password);

	// ユーザーを作成
	const user = await prisma.user.create({
		data: {
			email,
			password: hashed,
			name,
		},
	});

	// クッキーに userId をセット（HTTP Only, 1 週間有効）
	const cookieStore = cookies();
	cookieStore.set("userId", user.id, {
		httpOnly: true,
		secure: process.env.NODE_ENV === "production",
		maxAge: 60 * 60 * 24 * 7,
		path: "/",
	});

	// パスワードは返さない
	const { password: _, ...rest } = user;
	return rest as Omit<User, "password">;
}

/**
 * メール／パスワードでのサインイン。
 * 成功すれば cookie をセットします。
 */
export async function signIn(email: string, password: string) {
	const user = await prisma.user.findUnique({ where: { email } });
	if (!user) {
		throw new Error("User not found");
	}

	const isValid = await verifyPassword(password, user.password);
	if (!isValid) {
		throw new Error("Invalid password");
	}

	// cookie に userId をセット
	const cookieStore = cookies();
	cookieStore.set("userId", user.id, {
		httpOnly: true,
		secure: process.env.NODE_ENV === "production",
		maxAge: 60 * 60 * 24 * 7,
		path: "/",
	});

	const { password: _, ...rest } = user;
	return rest as Omit<User, "password">;
}

/**
 * サインアウト。cookie を削除してトップへリダイレクト。
 */
export async function signOut() {
	const cookieStore = cookies();
	cookieStore.delete("userId");
	redirect("/");
}

/**
 * 現在のユーザー情報を取得（パスワードは除く）。
 * ログインしていなければ null を返します。
 */
export async function getCurrentUser(): Promise<Omit<User, "password"> | null> {
	const cookieStore = cookies();
	const userId = cookieStore.get("userId")?.value;
	if (!userId) return null;

	const user = await prisma.user.findUnique({ where: { id: userId } });
	if (!user) return null;
	const { password: _, ...rest } = user;
	return rest as Omit<User, "password">;
}

/**
 * サーバー側のページ／API で「認証済みでなければサインインページへ」。
 */
export async function requireAuth() {
	const user = await getCurrentUser();
	if (!user) {
		redirect("/auth/signin");
	}
	return user;
}

/**
 * 「ADMIN ロール限定ページ」で使うガード
 */
export async function requireAdmin() {
	const user = await getCurrentUser();
	if (!user || user.role !== "ADMIN") {
		redirect("/auth/signin");
	}
	return user;
}
</file>

<file path="lib/db.ts">
import { PrismaClient } from '@prisma/client';

// PrismaClient is attached to the `global` object in development to prevent
// exhausting your database connection limit.
const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma = globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export default prisma;
</file>

<file path="lib/settings.ts">
// lib/settings.ts
import { prisma } from "@/lib/db";

export type SiteSetting = NonNullable<
	Awaited<ReturnType<typeof getSiteSetting>>
>;

export async function getSiteSetting() {
	return prisma.siteSetting.findFirst();
}

export async function upsertSiteSetting(data: Partial<SiteSetting>) {
	const existing = await getSiteSetting();
	if (existing) {
		await prisma.siteSetting.update({ where: { id: existing.id }, data });
	} else {
		await prisma.siteSetting.create({ data });
	}
}
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="lib/authOptions.ts">
// lib/authOptions.ts
import NextAuth, { type AuthOptions, type User } from "next-auth";
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import CredentialsProvider from "next-auth/providers/credentials";
import GoogleProvider from "next-auth/providers/google";
import { prisma } from "./db";
import { compare } from "bcrypt";

export const authOptions: AuthOptions = {
	adapter: PrismaAdapter(prisma),

	// JWT セッション
	session: { strategy: "jwt" },

	providers: [
		// Email/Password
		CredentialsProvider({
			name: "Credentials",
			credentials: {
				email: { label: "Email", type: "email" },
				password: { label: "Password", type: "password" },
			},
			async authorize(credentials) {
				if (!credentials?.email || !credentials?.password) {
					throw new Error("Invalid credentials");
				}
				const user = await prisma.user.findUnique({
					where: { email: credentials.email },
				});
				if (!user) throw new Error("User not found");
				const isValid = await compare(credentials.password, user.password);
				if (!isValid) throw new Error("Invalid password");
				return user;
			},
		}),

		// Google OAuth
		GoogleProvider({
			clientId: process.env.GOOGLE_CLIENT_ID ?? "",
			clientSecret: process.env.GOOGLE_CLIENT_SECRET ?? "",
			// profile.picture をそのまま使う
			profile(profile): User {
				return {
					id: profile.sub,
					name: profile.name,
					email: profile.email,
					image: profile.picture,
					role: profile.role,
				};
			},
		}),
	],

	callbacks: {
		// JWT に user.id, role, picture を乗せる
		async jwt({ token, user }) {
			if (user) {
				token.id = user.id;
				token.role = (user as User).role;
				token.picture = (user as User).image;
			}
			return token;
		},
		// Session に上記をマッピング
		async session({ session, token }) {
			if (session.user) {
				session.user.id = token.id as string;
				session.user.role = token.role as string;
				session.user.image = token.picture as string;
			}
			return session;
		},
	},

	events: {
		// 新規ユーザーにはデフォルト ROLE をセット
		createUser: async ({ user }) => {
			await prisma.user.update({
				where: { id: user.id },
				data: { role: "CUSTOMER" },
			});
		},
	},
};

export default NextAuth(authOptions);
</file>

<file path="lib/cloudinary.ts">
import { v2 as cloudinary } from "cloudinary";

cloudinary.config({
	cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
	api_key: process.env.CLOUDINARY_API_KEY,
	api_secret: process.env.CLOUDINARY_API_SECRET,
});

export async function uploadImage(imageData: string) {
	try {
		const result = await cloudinary.uploader.upload(imageData, {
			folder: "menu-items",
			transformation: [
				{ width: 1000, crop: "limit" }, // Original size
			],
		});

		// Generate thumbnail
		const thumbnail = await cloudinary.uploader.upload(imageData, {
			folder: "menu-items/thumbnails",
			transformation: [
				{ width: 300, height: 300, crop: "fill", gravity: "auto" },
			],
		});

		return {
			image: result.secure_url,
			thumbnail: thumbnail.secure_url,
			publicId: result.public_id,
		};
	} catch (error) {
		console.error("Error uploading image to Cloudinary:", error);
		throw new Error("Failed to upload image");
	}
}

export async function deleteImage(publicId: string) {
	try {
		await cloudinary.uploader.destroy(publicId);
		await cloudinary.uploader.destroy(
			`${publicId.split("/")[0]}/thumbnails/${publicId.split("/")[1]}`,
		);
	} catch (error) {
		console.error("Error deleting image from Cloudinary:", error);
		throw new Error("Failed to delete image");
	}
}
</file>

<file path="lib/menu.ts">
// lib/menu.ts
import { prisma } from "./db";

export type MenuItem = {
	id: string;
	name: string;
	description: string | null;
	price: number;
	image: string | null;
	thumbnail: string | null;
	available: boolean;
	featured: boolean;
	category: { id: string; name: string };
	createdAt: Date;
	updatedAt: Date;
};

export async function getFeaturedMenuItems() {
	// 「featured: true」を追加。available も念のため絞っておく
	const raw = await prisma.menuItem.findMany({
		where: { featured: true, available: true },
		orderBy: { createdAt: "desc" },
		take: 6, // 最大何件見せたいか
		include: { category: true }, // カテゴリ名も欲しいなら
	});

	// Decimal → number に変換
	return raw.map((item) => ({
		...item,
		price:
			typeof item.price.toNumber === "function"
				? item.price.toNumber()
				: Number(item.price),
	}));
}

export async function getMenuItems(): Promise<MenuItem[]> {
	const items = await prisma.menuItem.findMany({
		where: { available: true },
		include: { category: true }, // ← カテゴリを含める
		orderBy: { name: "asc" },
	});

	return items.map((item) => ({
		id: item.id,
		name: item.name,
		description: item.description,
		price: item.price.toNumber(),
		image: item.image,
		thumbnail: item.thumbnail,
		available: item.available,
		featured: item.featured,
		category: {
			id: item.category.id,
			name: item.category.name,
		},
		createdAt: item.createdAt,
		updatedAt: item.updatedAt,
	}));
}

export async function getMenuItem(id: string): Promise<MenuItem | null> {
	const item = await prisma.menuItem.findUnique({
		where: { id },
		include: { category: true }, // ← カテゴリを含める
	});
	if (!item) return null;

	return {
		id: item.id,
		name: item.name,
		description: item.description,
		price: item.price.toNumber(),
		image: item.image,
		thumbnail: item.thumbnail,
		available: item.available,
		featured: item.featured,
		category: {
			id: item.category.id,
			name: item.category.name,
		},
		createdAt: item.createdAt,
		updatedAt: item.updatedAt,
	};
}
</file>

</files>
